(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{548:function(v,i,l){"use strict";l.r(i);var _=l(9),e=Object(_.a)({},(function(){var v=this,i=v.$createElement,l=v._self._c||i;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h2",{attrs:{id:"activity-生命周期和启动模式"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#activity-生命周期和启动模式"}},[v._v("#")]),v._v(" Activity 生命周期和启动模式")]),v._v(" "),l("h3",{attrs:{id:"生命周期"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[v._v("#")]),v._v(" 生命周期")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("新 activity 采用透明主题，当前 activity 不会调用 onstop")])]),v._v(" "),l("li",[l("p",[v._v("启动新 activity，新的 onResume 和旧的 onPause 那个先执行？")]),v._v(" "),l("ul",[l("li",[v._v("旧的 onPause 先执行")]),v._v(" "),l("li",[v._v("尽量在 onStop 中做操作，从而使得 Activity 尽快显示并切换到前台")])])]),v._v(" "),l("li",[l("p",[v._v("onSaveInstance 在 onStop 之前，和 onPause 没必然联系")])]),v._v(" "),l("li",[l("p",[v._v("onRestoretore 在 onStart 之后")])]),v._v(" "),l("li",[l("p",[v._v("保存和恢复 view 的层次结构 p10")]),v._v(" "),l("ul",[l("li",[v._v("activity 意外终结时调用 onsaveInstance 保存数据，委托 window，window 委托顶层容器（通常 DecorView）保存数据。顶层容器一一通知子元素保存数据")])])]),v._v(" "),l("li",[l("p",[v._v("内存不足时资源回收顺序")])])]),v._v(" "),l("ol",[l("li",[v._v("空进程（没和应用程序组件绑定）")]),v._v(" "),l("li",[v._v("后台 activity")]),v._v(" "),l("li",[v._v("service")]),v._v(" "),l("li",[v._v("可见非前台 activity")]),v._v(" "),l("li",[v._v("前台 activity")])]),v._v(" "),l("h3",{attrs:{id:"启动模式"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#启动模式"}},[v._v("#")]),v._v(" 启动模式")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("standard 模式")]),v._v(" "),l("ul",[l("li",[v._v("standard 模式默认进入启动他的 activity 的任务栈中")]),v._v(" "),l("li",[v._v("非 activity 类型的 context 无任务栈，故用此类 context 启动 standard activity 会出错")]),v._v(" "),l("li",[v._v("解决上述问题的办法，为待启动 activity 制定 FLAG_ACTIVITY_NEW_TASK 标志位，相当于 singleTask")])])]),v._v(" "),l("li",[l("p",[v._v("singleTop")]),v._v(" "),l("ul",[l("li",[v._v("栈顶复用，栈顶已经存在调用 onNewIntent 方法")])])]),v._v(" "),l("li",[l("p",[v._v("singleTask")]),v._v(" "),l("ul",[l("li",[v._v("栈内复用，先查找只当任务栈，栈内已存在调用 onNewIntent 方法")])])]),v._v(" "),l("li",[l("p",[v._v("singleInstance")]),v._v(" "),l("ul",[l("li",[v._v("singleTask+只能单独存在于一任务栈中")]),v._v(" "),l("li",[v._v("✳ 注意后台任务栈多后台任务切换到前台的情况 p18")])])]),v._v(" "),l("li",[l("p",[v._v("TaskAffinity 属性")]),v._v(" "),l("ul",[l("li",[v._v("指定任务栈")]),v._v(" "),l("li",[v._v("主要和 singleTask 和 allowTaskReparenting 属性搭配（与 allowTaskReparenting 搭配的情况见 p20）")])])]),v._v(" "),l("li",[l("p",[v._v("如何给 activity 指定启动模式")]),v._v(" "),l("ul",[l("li",[v._v("manifest")]),v._v(" "),l("li",[v._v("intent 添加 flag(addFlags 方法)，两种方法均有时，以第二种方法为准")]),v._v(" "),l("li",[v._v("第一种方法无法指定 FLAG_CLEAR_TOP 属性，第二种方法无法指定 singleInstance")]),v._v(" "),l("li",[v._v("各种各样的标志位及其使用（可用于启动模式的转换）p27")])])]),v._v(" "),l("li",[l("p",[v._v("intent 隐式调用和显式调用时以显示为主")])]),v._v(" "),l("li",[l("p",[v._v("intent 的匹配模式 p29")]),v._v(" "),l("ul",[l("li",[v._v("action，其中一个，不区分大小写（必须有）")]),v._v(" "),l("li",[v._v("category，intent 中所有 category 必须和其中一个 category 匹配（可以没，默认加上 default category）")]),v._v(" "),l("li",[v._v("data,mimeType+URI\n"),l("ul",[l("li",[v._v("intent 指定完整的 data 必须调用 setDataAndType 方法，因为 setData 和 setType 方法会清空彼此的值。")])])])])]),v._v(" "),l("li",[l("p",[v._v("隐式启动时的判断方法 activity 是否能够匹配 intent 的两种方法 p34")]),v._v(" "),l("ul",[l("li",[v._v("PackageManager 的 resolveActivity（最佳匹配）,queryActivitys（所有成功匹配项）")]),v._v(" "),l("li",[v._v("或者 Intent 的 resolveActivity")]),v._v(" "),l("li",[v._v("匹配失败均返回 null")])])])]),v._v(" "),l("h2",{attrs:{id:"ipc"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#ipc"}},[v._v("#")]),v._v(" IPC")]),v._v(" "),l("ul",[l("li",[v._v("可以通过多进程获取多分内存空间")]),v._v(" "),l("li",[v._v("组件指定 process 属性使用多进程\n"),l("ul",[l("li",[v._v("：+进程名=包名+当前进程名，是当前应用私有进程，其他组件不能和它跑在一个进程里面")]),v._v(" "),l("li",[v._v("完整名字，全局进程，其他应用通过 shareUID 可以和它跑在同一进程里面\n"),l("ul",[l("li",[v._v("shareUID:每个应用唯一，UID 相同才能共享数据")])])])])]),v._v(" "),l("li",[v._v("Android 为每一个应用或进程分配了一个独立的虚拟机，导致不同虚拟机中访问同一对象会产生多个副本。")]),v._v(" "),l("li",[v._v("多进程造成的问题 p40\n"),l("ul",[l("li",[v._v("静态成员/单例无效。不是一块内存，不是一个对象")]),v._v(" "),l("li",[v._v("线程同步机制失效，同上")]),v._v(" "),l("li",[v._v("sharedPreference 可靠性下降，读写 XML 文件")]),v._v(" "),l("li",[v._v("Applicetion 多次创建。分配虚拟机即创建新的 application")])])]),v._v(" "),l("li",[v._v("实现进程间通信方式 p42\n"),l("ul",[l("li",[v._v("intent、共享文件、sharedPrefrence、基于 Binder 的 Messenger 和 AIDL、socket、contentProvider")])])]),v._v(" "),l("li",[v._v("序列化\n"),l("ul",[l("li",[v._v("serializable 接口\n"),l("ul",[l("li",[v._v("id 作用 p42")]),v._v(" "),l("li",[v._v("static、transient 关键字标记的成员变量不参与序列化")])])]),v._v(" "),l("li",[v._v("parcelable 接口")]),v._v(" "),l("li",[v._v("两种方式取舍 p47")])])])]),v._v(" "),l("h3",{attrs:{id:"binder"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#binder"}},[v._v("#")]),v._v(" Binder")]),v._v(" "),l("ul",[l("li",[v._v("各种方法的意义 p53")]),v._v(" "),l("li",[v._v("RPC 远程过程调用")])]),v._v(" "),l("h3",{attrs:{id:"messenger-的使用-p65"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#messenger-的使用-p65"}},[v._v("#")]),v._v(" Messenger 的使用 p65")]),v._v(" "),l("h3",{attrs:{id:"aidl-p73"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#aidl-p73"}},[v._v("#")]),v._v(" AIDL (P73)")]),v._v(" "),l("ul",[l("li",[v._v("自定义的 Parcelable 对象，必须显示的 import 进来，不管是否和当前 AIDL 文件处于一个文件夹")]),v._v(" "),l("li",[v._v("AIDL 用到自定义的 Parcelable 对象，必须新建一个同名 AIDL 文件，并在其中声明它为 Parcelable 类型")]),v._v(" "),l("li",[v._v("aidl 除基本类型的参数，需要标上方向")]),v._v(" "),l("li",[v._v("RemoteBackListener p84")]),v._v(" "),l("li",[v._v("Binder 是可能意外死亡的，两种重连服务的方式 P89\n"),l("ul",[l("li",[v._v("onServiceDisconnected，UI 线程")]),v._v(" "),l("li",[v._v("DeathRecipient 监听，Binder 线程池")])])]),v._v(" "),l("li",[v._v("权限认证 p90")])]),v._v(" "),l("h2",{attrs:{id:"view"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#view"}},[v._v("#")]),v._v(" View")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("位置")]),v._v(" "),l("ul",[l("li",[v._v("Left、right...都是相对父布局（原始）")]),v._v(" "),l("li",[v._v("x、y (真实)")]),v._v(" "),l("li",[v._v("translationX(偏移)")])])]),v._v(" "),l("li",[l("p",[v._v("TouchSlop 系统能被识别出的被认为是滑动的最小距离")]),v._v(" "),l("ul",[l("li",[v._v("ViewConfiguration.get(getContext()).getScaledTouchSlop();")])])]),v._v(" "),l("li",[l("p",[v._v("Velocity 速度 p126")]),v._v(" "),l("ul",[l("li",[v._v("在 onTouchEvent 中追踪")]),v._v(" "),l("li",[v._v("不使用时 clear 方法重置、recycle 方法回收")])])]),v._v(" "),l("li",[l("p",[v._v("GestureDetector 手势监听 p127")])]),v._v(" "),l("li",[l("p",[v._v("Scroller 弹性滑动对象 p128、p137")]),v._v(" "),l("ul",[l("li",[v._v("startScroll 本身没有做绘制操作，所以后面常接 computeScroll 方法")]),v._v(" "),l("li",[v._v("computeScroll 方法是 view 中的一个空实现，需要自己实现。view 在重绘后会在 draw 方法中调用 couputeScroll 方法，couputeScroll 方法又会去向 Scroller 获取当前的 scrollX 和 scrollY，然后通过 srcollTo 方法实现滑动，通过 postInvalidate 方法实现二次重绘，和一次重绘一样会导致 computeScroll 方法被调用，如此反复，直至滑动结束。")])])]),v._v(" "),l("li",[l("p",[v._v("实现滑动的三种方式\nscrollTo、scrollBy 内容")]),v._v(" "),l("ul",[l("li",[v._v("改变 layoutParams 使重新布局")]),v._v(" "),l("li",[v._v("施加平移效果（动画）")])])]),v._v(" "),l("li",[l("p",[v._v("View 的事件分发机制 P140")]),v._v(" "),l("ul",[l("li",[v._v("事件序列\n"),l("ul",[l("li",[v._v("手指接触屏幕到手指离开屏幕")])])]),v._v(" "),l("li",[v._v("dispatch...\n"),l("ul",[l("li",[v._v("分发，事件能传递到当前 view,则一定会被调用，返回结果表示是否消耗，受 onTouch...和下级 View 的 dispatch 影响")])])]),v._v(" "),l("li",[v._v("onIntercept...(注意读法)\n"),l("ul",[l("li",[v._v("返回结果表示是否拦截，如果拦截，同一事件序列此方法不会再次调用")])])]),v._v(" "),l("li",[v._v("onTouch...\n"),l("ul",[l("li",[v._v("处理点击，返回结果表示是否消耗，不消耗，同一事件序列中，当前 View 无法再次接受到事件。")])])])])]),v._v(" "),l("li",[l("p",[v._v("伪码表示 P141")])]),v._v(" "),l("li",[l("p",[v._v("onTouchListener 先于 onTouchEvent 调用")])]),v._v(" "),l("li",[l("p",[v._v("相关结论 p142")]),v._v(" "),l("ul",[l("li",[v._v("正常情况下一个事件序列之只能被一个 view 消耗")]),v._v(" "),l("li",[v._v("如果拦截，同一事件序列此方法不会再次调用，均交给该 view 处理")]),v._v(" "),l("li",[v._v("view 不消耗 ACTION_DOWN,同一事件序列交给父元素处理")]),v._v(" "),l("li",[v._v("viewGroup 默认不拦截")]),v._v(" "),l("li",[v._v("view 默认消耗，除非不可点击（click、longClick 同时 false）")]),v._v(" "),l("li",[v._v("onclick 前提可点击、收到 on、up 事件")])])])]),v._v(" "),l("h2",{attrs:{id:"view-的工作原理"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#view-的工作原理"}},[v._v("#")]),v._v(" View 的工作原理")]),v._v(" "),l("ul",[l("li",[v._v("measure 过程\n"),l("ul",[l("li",[v._v("子元素 measureSpec 由父容器 measureSpec 和子元素 layoutParams")]),v._v(" "),l("li",[v._v("重写 view 需要注意处理 wrap_content 和 padding")]),v._v(" "),l("li",[v._v("获取宽高 p190\n"),l("ul",[l("li",[v._v("view 的 measure 过程和 activity 的生命周期并不是同步的，故生命周期中获取宽高可能为 0，故获取宽高应该采取下面的方法")]),v._v(" "),l("li",[v._v("onWindowFoucusChanged.\n"),l("ul",[l("li",[v._v("获取、失去焦点时调用")])])]),v._v(" "),l("li",[v._v("view.post(runnable)\n"),l("ul",[l("li",[v._v("投递到消息队列尾，Looperd 调用 runnable 时，View 已经初始话好")])])]),v._v(" "),l("li",[v._v("viewTreeObserver 的回调方法\n"),l("ul",[l("li",[v._v("view 树的状态发生改变或内部 view 可见性发生改变时，onClobalLayout 方法将会回调，是获取 view 宽高的好机会")])])]),v._v(" "),l("li",[v._v("手动调用 measure 方法")])])])])]),v._v(" "),l("li",[v._v("layout 过程\n"),l("ul",[l("li",[v._v("layout 方法确定 view 位置（里面主要 setFrame 方法设置 4 个定点），onLayout 方法（里面主要通过 setChildFrame 调用子元素的 layout 方法）确定子元素位置")]),v._v(" "),l("li",[v._v("测量宽高在 measure 过程、最终宽高在 layout 过程，通常相等")])])]),v._v(" "),l("li",[v._v("draw 过程\n"),l("ul",[l("li",[v._v("画背景 background.draw(canvas)")]),v._v(" "),l("li",[v._v("画自己 onDraw")]),v._v(" "),l("li",[v._v("画 children dispatchDraw")]),v._v(" "),l("li",[v._v("画装饰 onDrawScrollBars")])])]),v._v(" "),l("li",[v._v("自定义 view 须知 P201\n"),l("ul",[l("li",[v._v("注意处理 wrap_content\\padding 情况")]),v._v(" "),l("li",[v._v("尽量不要使用 handler，没必要，view 提供了 post 方法")]),v._v(" "),l("li",[v._v("view 有线程或动画的时候需要及时停止 p201")]),v._v(" "),l("li",[v._v("参考 onDetachFromWindow")]),v._v(" "),l("li",[v._v("处理滑动冲突")])])])])])}),[],!1,null,null,null);i.default=e.exports}}]);